networks:
  arrnet:
    driver: bridge

services:
  gluetun:
    image: qmcgaw/gluetun:latest
    container_name: gluetun
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8000/v1/publicip/ip"]
      interval: 30s
      timeout: 10s
      retries: 3
    cap_add:
      - NET_ADMIN
      - NET_RAW
    devices:
      - /dev/net/tun:/dev/net/tun
    networks:
      - arrnet
    environment:
      - MTU=1400
      - TZ=${TZ}

      # VPN Configuration
      - VPN_SERVICE_PROVIDER=private internet access
      - VPN_TYPE=openvpn

      # PIA Authentication
      - OPENVPN_USER=${PIA_USER}
      - OPENVPN_PASSWORD=${PIA_PASS}

      # Pick one region (see .env)
      - SERVER_REGIONS=${PIA_REGION}

      # Allow your LAN to reach the published ports
      - FIREWALL_OUTBOUND_SUBNETS=192.168.4.0/22

      # Port forwarding (PIA only)
      - VPN_PORT_FORWARDING=true
      - VPN_PORT_FORWARDING_PROVIDER=private internet access
      - VPN_PORT_FORWARDING_STATUS_FILE=/gluetun/forwarded_port

      - HTTP_CONTROL_SERVER_ADDRESS=:8000
    volumes:
      - /srv/appdata/gluetun:/gluetun
    ports:
      # qBittorrent Web UI (qBittorrent shares gluetun's network namespace)
      - 8080:8080
      # gluetun status web UI
      - 8000:8000
    restart: unless-stopped

  qbittorrent:
    image: lscr.io/linuxserver/qbittorrent:latest
    container_name: qbittorrent
    network_mode: "service:gluetun"
    depends_on:
      gluetun:
        condition: service_healthy
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
      - TZ=${TZ}
      - WEBUI_PORT=8080
      # Seed with a default; qbit-port-sync will keep it updated
      - TORRENTING_PORT=6881
    volumes:
      - /srv/appdata/qbittorrent:/config
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8080/api/v2/app/version"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s

  # Watches /gluetun/forwarded_port and pushes it into qBittorrent via Web API
  qbit-port-sync:
    image: alpine:3.20
    container_name: qbit-port-sync
    networks:
      - arrnet
    depends_on:
      gluetun:
        condition: service_healthy
      qbittorrent:
        condition: service_started
    #network-mode: "service:gluetun"
    environment:
      - QB_HOST=gluetun
      - QB_PORT=8080
      - QB_USER=${QBIT_USER}
      - QB_PASS=${QBIT_PASS}
      - PF_FILE=/gluetun/forwarded_port
    volumes:
      - /srv/appdata/gluetun:/gluetun:ro
    command: >
      sh -c '
        apk add --no-cache curl jq >/dev/null 2>&1;
        echo "[qbit-port-sync] starting";
        last="";
        while true; do
          if [ -f "$$PF_FILE" ]; then
            pf="$$(cat $$PF_FILE | tr -d "\r\n" | tr -cd "0-9")";
            if [ -n "$$pf" ] && [ "$$pf" != "$$last" ]; then
              echo "[qbit-port-sync] new forwarded port: $$pf";

              curl -s -c /tmp/cookies.txt                 -d "username=$$QB_USER&password=$$QB_PASS"                 "http://$$QB_HOST:$$QB_PORT/api/v2/auth/login" >/dev/null;

              curl -s -b /tmp/cookies.txt                 --data-urlencode "json={\"listen_port\":$$pf}"                 "http://$$QB_HOST:$$QB_PORT/api/v2/app/setPreferences" >/dev/null;

              curl -s -b /tmp/cookies.txt                 "http://$$QB_HOST:$$QB_PORT/api/v2/auth/logout" >/dev/null;

              last="$$pf";
            fi
          fi
          sleep 30;
        done
      '
    restart: unless-stopped

  qbit-restart-on-vpn:
    image: docker:27-cli
    container_name: qbit-restart-on-vpn
    networks:
      - arrnet
    depends_on:
      gluetun:
        condition: service_healthy
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./scripts/qbit-restart-on-vpn.sh:/usr/local/bin/qbit-restart-on-vpn.sh:ro

    environment:
      - GLUETUN_CONTAINER=gluetun
      - QBIT_CONTAINER=qbittorrent
      - CHECK_INTERVAL=10
    command: ["/usr/local/bin/qbit-restart-on-vpn.sh"]
    restart: "unless-stopped"

  prowlarr:
    image: lscr.io/linuxserver/prowlarr:latest
    container_name: prowlarr
    networks:
      - arrnet
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
      - TZ=${TZ}
    volumes:
      - /srv/appdata/prowlarr:/config
    ports:
      - 9696:9696
    restart: unless-stopped

  radarr:
    image: lscr.io/linuxserver/radarr:latest
    container_name: radarr
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7878/ping"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - arrnet
    depends_on:
      qbittorrent:
        condition: service_healthy
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
      - TZ=${TZ}
    volumes:
      - /srv/appdata/radarr:/config
    ports:
      - 7878:7878
    restart: unless-stopped

  sonarr:
    image: lscr.io/linuxserver/sonarr:latest
    container_name: sonarr
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8989/ping"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - arrnet
    depends_on:
      qbittorrent:
        condition: service_healthy

    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
      - TZ=${TZ}
    volumes:
      - /srv/appdata/sonarr:/config
    ports:
      - 8989:8989
    restart: unless-stopped

  overseerr:
    image: lscr.io/linuxserver/overseerr:latest
    container_name: overseerr
    networks:
      - arrnet
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
      - TZ=${TZ}
    volumes:
      - /srv/appdata/overseerr:/config
    ports:
      - 5055:5055
    restart: unless-stopped

  bazarr:
    image: lscr.io/linuxserver/bazarr:latest
    container_name: bazarr
    networks:
      - arrnet
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
      - TZ=${TZ}
    volumes:
      - /srv/appdata/bazarr:/config
    ports:
      - 6767:6767
    restart: unless-stopped

  recyclarr:
    image: ghcr.io/recyclarr/recyclarr:latest
    container_name: recyclarr
    networks:
      - arrnet
    user: "${PUID}:${PGID}"
    environment:
      - TZ=${TZ}
      - RECYCLARR_CREATE_CONFIG=false
      - RADARR_API_KEY=${RADARR_API_KEY}
      - SONARR_API_KEY=${SONARR_API_KEY}
      # Runs a sync on a schedule. Daily at 3:30am:
      - CRON_SCHEDULE=30 3 * * *
    volumes:
      - /srv/appdata/recyclarr:/config:rw
      - ./recyclarr/configs:/config/configs:ro
      - ./recyclarr/includes:/config/includes:ro
    restart: unless-stopped
    depends_on:
      sonarr:
        condition: service_healthy
      radarr:
        condition: service_healthy

  qbit_manage:
    image: ghcr.io/stuffanthings/qbit_manage:latest
    container_name: qbit_manage
    networks:
      - arrnet
    user: "${PUID}:${PGID}"
    environment:
      - TZ=${TZ}
      - QBT_RUN=false
      - QBT_CONFIG=/config/config.yml
      - QBT_LOGFILE=/config/logs/activity.log
      # Runs every N minutes (default shown in .env.example)
      - QBT_SCHEDULE=${QBIT_MANAGE_SCHEDULE:-180}
      # Safety default: no changes until you explicitly disable dry-run
      - QBT_DRY_RUN=${QBIT_MANAGE_DRY_RUN:-true}
      # Safe starter commands: tags only, no deletions
      - QBT_TAG_UPDATE=true
      - QBT_TAG_TRACKER_ERROR=true
      - QBT_REM_UNREGISTERED=false
      - QBT_REM_ORPHANED=false
      - QBT_TAG_NOHARDLINKS=false
      - QBT_SHARE_LIMITS=false
      - QBT_RECHECK=false
      - QBT_CAT_UPDATE=false
      - QBT_WEB_SERVER=true
      - QBT_PORT=8088
    ports:
      - 8088:8088
    volumes:
      - /srv/appdata/qbit_manage:/config:rw
    restart: unless-stopped
    depends_on:
      gluetun:
        condition: service_healthy
      qbittorrent:
        condition: service_healthy

